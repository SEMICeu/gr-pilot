<?vsp
-- /doc and /about handler script
--
-- Copyright 2014 PwC EU Services
--
-- Licensed under the EUPL, Version 1.1 or - as soon they
-- will be approved by the European Commission - subsequent
-- versions of the EUPL (the "Licence");
-- You may not use this work except in compliance with the
-- Licence.
-- You may obtain a copy of the Licence at:
-- http://ec.europa.eu/idabc/eupl
--
-- Unless required by applicable law or agreed to in
-- writing, software distributed under the Licence is
-- distributed on an "AS IS" basis,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
-- express or implied.
-- See the Licence for the specific language governing
-- permissions and limitations under the Licence.

-- The current_charset in VSPs seems to always be ISO-8859-1. Hence, all
-- parameters are interpreted as such. By setting http_charset, we avoid
-- recoding them. This preserves the UTF-8 meaning of the values when passed
-- further on in, e.g., http_proxy.
set http_charset=current_charset();

-- Read HTTP parameters
declare _type, _id, _uri, _format, uri varchar;
_type := get_keyword('type', params, '');
_id := get_keyword('id', params, '');
_uri := get_keyword('uri', params, '');
_format := get_keyword('format', params, '');

-- Fallbacks
if(_uri = '') {
  if(_id = '') {
    _uri := sprintf('%BASEURI%id/%U', _type);
  } else {
    _uri := sprintf('%BASEURI%id/%U/%U', _type, _id);
  }
}

if(_format = '') {
  declare accept varchar;
  accept := http_request_header(lines, 'Accept');
  if(regexp_like(accept, 'application/rdf.xml')) {
    _format := 'rdf';
  } else if(regexp_like(accept, 'text/rdf.n3|text/rdf.turtle|text/turtle')) {
    _format := 'ttl';
  }
}

-- Handle raw RDF data
if(_format = 'rdf' or _format = 'ttl') {
  declare query, format varchar;
  query := sprintf('DESCRIBE <%s>', _uri);
  if(_format = 'rdf') {
    format := 'application/rdf+xml';
  } else if(_format = 'ttl') {
    format := 'text/rdf+n3';
  }
  http_proxy('localhost',
             vector(sprintf('GET /sparql?query=%U&format=%U HTTP/1.0', query, format)),
             null);
  return null;
}

-- Determine query and stylesheet depending on requested type
declare query, stylesheet varchar;
if(_type = 'address' and _id <> '') {
  query := 'CONSTRUCT {
    <URI> a locn:Address ;
      rdfs:label ?label ;
      locn:thoroughfare ?street ;
      locn:locatorDesignator ?number ;
      locn:postCode ?postcode ;
      locn:adminUnitL2 ?municipality ;
      locn:adminUnitL1 ?country .
    ?org locn:address <URI> ;
      rdfs:label ?orglabel .
  } WHERE {
    <URI> a locn:Address ;
      rdfs:label ?label .
    OPTIONAL { <URI> locn:thoroughfare ?street }
    OPTIONAL { <URI> locn:locatorDesignator ?number }
    OPTIONAL { <URI> locn:postCode ?postcode }
    OPTIONAL { <URI> locn:adminUnitL2 ?municipality }
    OPTIONAL { <URI> locn:adminUnitL1 ?country }
    ?org locn:address <URI> ;
      rdfs:label ?orglabel .
  }';
  stylesheet := 'address.xsl';
} else if(_type = 'organization' and _id <> '') {
  query := 'CONSTRUCT {
    <URI> a org:Organization ;
      rdfs:label ?label ;
      org:identifier ?identifier ;
      rov:orgType ?type ;
      org:classification ?category ;
      org:subOrganizationOf ?parent ;
      locn:address ?address ;
      foaf:phone ?phone .
    ?type rdfs:label ?typelabel .
    ?category rdfs:label ?categorylabel .
    ?parent rdfs:label ?parentlabel .
    ?child org:subOrganizationOf <URI> ;
      rdfs:label ?childlabel .
    ?address a locn:Address ;
      rdfs:label ?addrlabel ;
      locn:thoroughfare ?street ;
      locn:locatorDesignator ?number ;
      locn:postCode ?postcode ;
      locn:adminUnitL2 ?municipality ;
      locn:adminUnitL1 ?country .
  } WHERE {
    {
      <URI> a org:Organization ;
        rdfs:label ?label ;
        org:identifier ?identifier .
      OPTIONAL { <URI> rov:orgType ?type .
                 ?type rdfs:label ?typelabel . }
      OPTIONAL { <URI> org:classification ?category .
                 ?category rdfs:label ?categorylabel . }
      OPTIONAL { <URI> org:subOrganizationOf ?parent .
                 ?parent rdfs:label ?parentlabel . }
    } UNION {
      { SELECT * WHERE {
          ?child org:subOrganizationOf <URI> ;
            rdfs:label ?childlabel .
        } }
    } UNION {
      { SELECT * WHERE {
          <URI> locn:address ?address .
          ?address a locn:Address ;
            rdfs:label ?addrlabel .
          OPTIONAL { ?address locn:thoroughfare ?street }
          OPTIONAL { ?address locn:locatorDesignator ?number }
          OPTIONAL { ?address locn:postCode ?postcode }
          OPTIONAL { ?address locn:adminUnitL2 ?municipality }
          OPTIONAL { ?address locn:adminUnitL1 ?country }
        } }
    } UNION {
      { SELECT * WHERE {
          <URI> foaf:phone ?phone .
        } }
    }
  }';
  stylesheet := 'organization.xsl';
} else {
  query := 'SELECT DISTINCT * WHERE {
    {
      <URI> ?p ?o
      OPTIONAL { { SELECT ?p SAMPLE(?label) AS ?plabel
                   WHERE { ?p rdfs:label ?label } GROUP BY ?p } }
      OPTIONAL { { SELECT ?o SAMPLE(?label) AS ?olabel
                   WHERE { ?o rdfs:label ?label } GROUP BY ?o } }
    } UNION {
      ?s ?ip <URI>
      OPTIONAL { { SELECT ?ip SAMPLE(?label) AS ?iplabel
                   WHERE { ?ip rdfs:label ?label } GROUP BY ?ip } }
      OPTIONAL { { SELECT ?s SAMPLE(?label) AS ?slabel
                   WHERE { ?s rdfs:label ?label } GROUP BY ?s } }
    }
    BIND(<URI> AS ?target)
  } ORDER BY ?ip ?p';
  stylesheet := 'about.xsl';
}

query := replace(query, '<URI>', sprintf('<%s>', _uri));
stylesheet := sprintf('%ROOTURI%xslt/%s', stylesheet);

-- Execute the query and process it with the stylesheet.
if(starts_with(query, 'SELECT')) {
  -- There does not seem to be a function to get SPARQL results in XML format.
  -- Proxy the query through the /sparql service.
  -- Note: there is a limit on the length of the query using this method.
  declare url varchar;
  url := sprintf('/sparql?query=%U&format=%U&xslt-uri=%U',
                 query,
                 'application/sparql-results+xml',
                 stylesheet);
  http_proxy('localhost', vector(sprintf('GET %s HTTP/1.0', url)), null);
} else {
  declare rset, triples, rawxml any;
  rset := DB.DBA.SPARQL_EVAL_TO_ARRAY(query, null, 0);
  triples := dict_list_keys (rset[0][0], 1);
  rawxml := string_output();
  DB.DBA.RDF_TRIPLES_TO_RDF_XML_TEXT(triples, 1, rawxml);
  http(string_output_string(rawxml));
  http_xslt(stylesheet);
}
?>
